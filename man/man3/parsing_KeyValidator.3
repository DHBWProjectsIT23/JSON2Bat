.TH "parsing::KeyValidator" 3 "Fri Apr 26 2024 10:00:36" "Version 0.2.2" "JSON2Batch" \" -*- nroff -*-
.ad l
.nh
.SH NAME
parsing::KeyValidator \- Validates keys of a Json::Value object\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <KeyValidator\&.hpp>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "std::vector< std::tuple< int, std::string > > \fBvalidateKeys\fP (const Json::Value &root, const std::string &filename)"
.br
.RI "Validate keys off a Json::Value object\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBKeyValidator\fP & \fBgetInstance\fP ()"
.br
.RI "Get the instance of this class\&. "
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "std::vector< std::tuple< int, std::string > > \fBgetWrongKeys\fP (const Json::Value &root, const std::string &filename) const"
.br
.RI "Retrieve the wrong keys from a Json::Value object\&. "
.ti -1c
.RI "void \fBvalidateTypes\fP (const std::string &filename, const Json::Value &entry, const std::unordered_set< std::string > &entryKeys)"
.br
.RI "Validates types from the entries array\&. "
.ti -1c
.RI "std::vector< std::tuple< int, std::string > > \fBvalidateEntries\fP (const std::string &filename, const std::unordered_set< std::string > &entryKeys) const"
.br
.RI "Validates that an entries 'type' key is valid\&. "
.in -1c
.SS "Static Private Member Functions"

.in +1c
.ti -1c
.RI "static std::optional< int > \fBgetUnknownKeyLine\fP (const std::string &filename, const std::string &wrongKey)"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "std::unordered_set< std::string > \fBvalidKeys\fP"
.br
.ti -1c
.RI "std::unordered_set< std::string > \fBvalidEntryKeys\fP"
.br
.ti -1c
.RI "std::unordered_map< std::string_view, std::vector< std::string > > \fBtypeToKeys\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Validates keys of a Json::Value object\&. 

This class is singleton\&. That way when multiple files are parsed with the application, the validKeys and validEntryKeys field only have to be allocated once\&. 
.PP
Definition at line \fB28\fP of file \fBKeyValidator\&.hpp\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "\fBKeyValidator\fP & parsing::KeyValidator::getInstance ()\fC [static]\fP"

.PP
Get the instance of this class\&. 
.PP
\fBReturns\fP
.RS 4
Reference to the instance of this class 
.RE
.PP

.PP
Definition at line \fB21\fP of file \fBKeyValidator\&.cpp\fP\&.
.SS "std::optional< int > parsing::KeyValidator::getUnknownKeyLine (const std::string & filename, const std::string & wrongKey)\fC [static]\fP, \fC [private]\fP"

.PP
\fBParameters\fP
.RS 4
\fIfilename\fP 
.br
\fIwrongKey\fP 
.RE
.PP
\fBReturns\fP
.RS 4
.RE
.PP
\fBTodo\fP
.RS 4
Documentation 
.RE
.PP

.PP
Definition at line \fB117\fP of file \fBKeyValidator\&.cpp\fP\&.
.SS "std::vector< std::tuple< int, std::string > > parsing::KeyValidator::getWrongKeys (const Json::Value & root, const std::string & filename) const\fC [private]\fP"

.PP
Retrieve the wrong keys from a Json::Value object\&. This method goes through each key of the Json::Value object and makes sure it's valid\&.
.PP
\fBParameters\fP
.RS 4
\fIroot\fP The Json::Value object to be validated\&. 
.br
\fIfilename\fP The filename from which 'root' is from\&.
.RE
.PP
\fBReturns\fP
.RS 4
A vector with tuples, containing the line and name of invalid types\&. 
.RE
.PP

.PP
Definition at line \fB51\fP of file \fBKeyValidator\&.cpp\fP\&.
.PP
References \fBgetUnknownKeyLine()\fP, and \fBvalidKeys\fP\&.
.SS "std::vector< std::tuple< int, std::string > > parsing::KeyValidator::validateEntries (const std::string & filename, const std::unordered_set< std::string > & entryKeys) const\fC [private]\fP"

.PP
Validates that an entries 'type' key is valid\&. 
.PP
\fBParameters\fP
.RS 4
\fIfilename\fP 
.br
\fIentryKeys\fP 
.RE
.PP
\fBReturns\fP
.RS 4
.RE
.PP
\fBTodo\fP
.RS 4
Documentation 
.RE
.PP

.PP
Definition at line \fB71\fP of file \fBKeyValidator\&.cpp\fP\&.
.PP
References \fBgetUnknownKeyLine()\fP, and \fBvalidEntryKeys\fP\&.
.SS "std::vector< std::tuple< int, std::string > > parsing::KeyValidator::validateKeys (const Json::Value & root, const std::string & filename)"

.PP
Validate keys off a Json::Value object\&. This method goes through the MemberNames of a Json::Value object and validates, that they are part of the validKey attribute\&. It calls the nessecary methods to validate the keys within the entries array\&.
.PP
\fBParameters\fP
.RS 4
\fIroot\fP The Json::Value object to be validated\&. 
.br
\fIfilename\fP The filename from which 'root' is from\&. 
.RE
.PP
\fBReturns\fP
.RS 4
A vector with tuples, containing the line and name of invalid types\&. 
.RE
.PP

.PP
Definition at line \fB28\fP of file \fBKeyValidator\&.cpp\fP\&.
.PP
References \fBgetWrongKeys()\fP, \fBvalidateEntries()\fP, and \fBvalidateTypes()\fP\&.
.SS "void parsing::KeyValidator::validateTypes (const std::string & filename, const Json::Value & entry, const std::unordered_set< std::string > & entryKeys)\fC [private]\fP"

.PP
Validates types from the entries array\&. Makes sure that each type has it's according keys, needed to parse it\&.
.PP
\fBParameters\fP
.RS 4
\fIfilename\fP The filename from which 'entry' is from 
.br
\fIentry\fP 
.br
\fIentryKeys\fP 
.RE
.PP

.PP
Definition at line \fB92\fP of file \fBKeyValidator\&.cpp\fP\&.
.PP
References \fBgetUnknownKeyLine()\fP, and \fBtypeToKeys\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "std::unordered_map<std::string_view, std::vector<std::string> > parsing::KeyValidator::typeToKeys\fC [private]\fP"
\fBInitial value:\fP.PP
.nf
= {
      {"EXE", {"command"}}, {"PATH", {"path"}}, {"ENV", {"key", "value"}}}
.fi

.PP
Definition at line \fB113\fP of file \fBKeyValidator\&.hpp\fP\&.
.SS "std::unordered_set<std::string> parsing::KeyValidator::validEntryKeys\fC [private]\fP"
\fBInitial value:\fP.PP
.nf
= {"type", "key", "value",
                                                    "path", "command"}
.fi

.PP
Definition at line \fB110\fP of file \fBKeyValidator\&.hpp\fP\&.
.SS "std::unordered_set<std::string> parsing::KeyValidator::validKeys\fC [private]\fP"
\fBInitial value:\fP.PP
.nf
= {"outputfile", "hideshell",
                                               "entries", "application"}
.fi

.PP
Definition at line \fB108\fP of file \fBKeyValidator\&.hpp\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for JSON2Batch from the source code\&.
